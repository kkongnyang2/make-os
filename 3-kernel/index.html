
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../2-hw/">
      
      
        <link rel="next" href="../4-MMU/">
      
      
      <link rel="icon" href="../logo.svg">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.15">
    
    
      
        <title>3 kernel - Make-OS</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.342714a4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Inter";--md-code-font:"JetBrains Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../soft-era.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="apple" data-md-color-primary="white" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#xv6-riscv" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Make-OS" class="md-header__button md-logo" aria-label="Make-OS" data-md-component="logo">
      
  <img src="../logo.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Make-OS
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              3 kernel
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="apple" data-md-color-primary="white" data-md-color-accent="indigo"  aria-label="Soft Era"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Soft Era" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m20.71 4.63-1.34-1.34c-.37-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.04 0-1.41M7 14a3 3 0 0 0-3 3c0 1.31-1.16 2-2 2 .92 1.22 2.5 2 4 2a4 4 0 0 0 4-4 3 3 0 0 0-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="soft" data-md-color-primary="custom" data-md-color-accent="custom"  aria-label="Apple Classic"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Apple Classic" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m20.71 4.63-1.34-1.34c-.37-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.04 0-1.41M7 14a3 3 0 0 0-3 3c0 1.31-1.16 2-2 2 .92 1.22 2.5 2 4 2a4 4 0 0 0 4-4 3 3 0 0 0-3-3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../1-vm/" class="md-tabs__link">
        
  
  
    
  
  1 vm

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../2-hw/" class="md-tabs__link">
        
  
  
    
  
  2 hw

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="./" class="md-tabs__link">
        
  
  
    
  
  3 kernel

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../4-MMU/" class="md-tabs__link">
        
  
  
    
  
  4 MMU

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../5-trap/" class="md-tabs__link">
        
  
  
    
  
  5 trap

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../6-PCB/" class="md-tabs__link">
        
  
  
    
  
  6 PCB

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../7-uart/" class="md-tabs__link">
        
  
  
    
  
  7 uart

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../8-mkfs/" class="md-tabs__link">
        
  
  
    
  
  8 mkfs

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../9-build/" class="md-tabs__link">
        
  
  
    
  
  9 build

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../mini-os/" class="md-tabs__link">
        
  
  
    
  
  Mini os

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Make-OS" class="md-nav__button md-logo" aria-label="Make-OS" data-md-component="logo">
      
  <img src="../logo.svg" alt="logo">

    </a>
    Make-OS
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../1-vm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    1 vm
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../2-hw/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2 hw
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    3 kernel
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    3 kernel
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#xv6-riscv" class="md-nav__link">
    <span class="md-ellipsis">
      xv6-riscv의 시작 파일을 읽어보자
    </span>
  </a>
  
    <nav class="md-nav" aria-label="xv6-riscv의 시작 파일을 읽어보자">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      목표: 커널의 이해
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      0&gt; 파일 구조
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-kernelkernelld" class="md-nav__link">
    <span class="md-ellipsis">
      1&gt; 메모리 배치 kernel/kernel.ld
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-m-kernelentrys" class="md-nav__link">
    <span class="md-ellipsis">
      2&gt; M모드 및 스택 설정 kernel/entry.S
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-m-s-timer-kernelstartc" class="md-nav__link">
    <span class="md-ellipsis">
      3&gt; M-&gt;S 전환, timer 세팅 kernel/start.c
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-kernelmainc" class="md-nav__link">
    <span class="md-ellipsis">
      4&gt; 커널 초기화 루틴 kernel/main.c
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5&gt; 모드 전환
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#makefile" class="md-nav__link">
    <span class="md-ellipsis">
      &gt; makefile
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../4-MMU/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    4 MMU
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../5-trap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    5 trap
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../6-PCB/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    6 PCB
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../7-uart/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    7 uart
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../8-mkfs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    8 mkfs
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../9-build/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    9 build
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../mini-os/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Mini os
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#xv6-riscv" class="md-nav__link">
    <span class="md-ellipsis">
      xv6-riscv의 시작 파일을 읽어보자
    </span>
  </a>
  
    <nav class="md-nav" aria-label="xv6-riscv의 시작 파일을 읽어보자">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      목표: 커널의 이해
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#0" class="md-nav__link">
    <span class="md-ellipsis">
      0&gt; 파일 구조
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-kernelkernelld" class="md-nav__link">
    <span class="md-ellipsis">
      1&gt; 메모리 배치 kernel/kernel.ld
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-m-kernelentrys" class="md-nav__link">
    <span class="md-ellipsis">
      2&gt; M모드 및 스택 설정 kernel/entry.S
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-m-s-timer-kernelstartc" class="md-nav__link">
    <span class="md-ellipsis">
      3&gt; M-&gt;S 전환, timer 세팅 kernel/start.c
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-kernelmainc" class="md-nav__link">
    <span class="md-ellipsis">
      4&gt; 커널 초기화 루틴 kernel/main.c
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5&gt; 모드 전환
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#makefile" class="md-nav__link">
    <span class="md-ellipsis">
      &gt; makefile
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



  <h1>3 kernel</h1>

<h2 id="xv6-riscv">xv6-riscv의 시작 파일을 읽어보자</h2>
<h3 id="_1">목표: 커널의 이해</h3>
<p>작성자: kkongnyang2 작성일: 2025-06-21</p>
<hr />
<h3 id="0">0&gt; 파일 구조</h3>
<p>[1] 부트 진입<br />
[2] 커널 초기화<br />
[3] 트랩 핸들러 등록<br />
[4] 타이머 인터럽트 활성화<br />
[5] init 프로세스 시작<br />
[6] 유저 스페이스 → 시스템 콜 → 커널 진입</p>
<div class="highlight"><pre><span></span><code>xv6-riscv/
├── Makefile           ← 빌드 명령 정의
├── kernel/            ← 커널 코드가 담긴 디렉토리
│   ├── entry.S        ← 커널 진입점 (Assembly)
│   ├── start.c        ← 초기화 루틴
│   ├── main.c         ← 커널 main 함수
│   ├── trap.c         ← 트랩/인터럽트 처리
│   ├── syscall.c      ← 시스템 콜 디스패치
│   ├── proc.c         ← 프로세스 생성/스케줄링
│   ├── vm.c           ← 페이지 테이블 및 메모리 관리
│   ├── kalloc.c       ← 물리 메모리 할당자
│   ├── file.c, fs.c   ← 파일 시스템
│   ├── uart.c         ← UART 드라이버
│   ├── spinlock.c     ← 스핀락
│   └── ...            ← 다양한 커널 서브시스템
├── user/              ← 사용자 영역 프로그램
│   ├── init.c         ← 최초 유저 프로그램
│   ├── sh.c           ← 셸
│   └── ...            ← ls, cat, echo 등 유틸들
├── fs/                ← 파일 시스템
│   └── fs.img         ← 초기 파일 시스템 이미지
├── mkfs/              ← 파일 시스템 이미지 생성 도구
│   └── mkfs.c
├── include/           ← 커널/유저 공용 헤더
│   └── *.h
├── .gdbinit           ← GDB 초기화 설정
└── README.md
</code></pre></div>
<h3 id="1-kernelkernelld">1&gt; 메모리 배치 kernel/kernel.ld</h3>
<p>링커 스크립트란? .o 들을 하나로 묶어 실행 가능한 .elf 바이너리를 만들때, 어떤 섹션을 어디에 배치할지 결정하는 배치도 역할을 한다.<br />
<div class="highlight"><pre><span></span><code>OUTPUT_ARCH( &quot;riscv&quot; )
ENTRY( _entry )

SECTIONS
{
  /*
   * ensure that entry.S / _entry is at 0x80000000,
   * where qemu&#39;s -kernel jumps.
   */
  . = 0x80000000;

  .text : {                     // 실행 가능한 코드들을 이 섹션에 배치
    *(.text .text.*)            // 일반 C/어셈블리 코드
    . = ALIGN(0x1000);          // 4KB 정렬 (페이지 단위)
    _trampoline = .;            // 트램폴린 시작 위치 저장
                                // 트램폴린이란 유저 모드에서 커널 모드로 돌아올 때 필요한 임시 코드 공간. 각 프로세스의 trap handler가 점프하는 장소
    *(trampsec)                 // 트램폴린 코드 삽입
    . = ALIGN(0x1000);          // 다시 4KB 정렬
    ASSERT(. - _trampoline == 0x1000, &quot;error: trampoline larger than one page&quot;);
    //크기 체크. 혹여라도 1페이지(4KB)로 정렬 안됐을까봐.
    PROVIDE(etext = .);         // etext라는 심볼로 현재 주소 커서 저장. 텍스트 끝 주소를 알 수 있게.
  }

  .rodata : {                   // 읽기 전용 데이터들(const)
    . = ALIGN(16);              // 16바이트 정렬
    *(.srodata .srodata.*)      // srodata는 작은 상수들을 위한 별도 섹션
    . = ALIGN(16);
    *(.rodata .rodata.*)
  }

  .data : {                     // 초기화된 전역변수
    . = ALIGN(16);
    *(.sdata .sdata.*)          // sdata는 작은 초기화된 전역 변수
    . = ALIGN(16);
    *(.data .data.*)
  }

  .bss : {                      // 초기화 안된 전역변수(초기값x)
    . = ALIGN(16);
    *(.sbss .sbss.*)            // 작은
    . = ALIGN(16);
    *(.bss .bss.*)
  }

  PROVIDE(end = .);             // end라는 심볼로 현재 주소 커서 저장. 커널의 끝 주소를 알 수 있게. 이 이후부턴 heap, user memory, alloc 등 시작.
}
</code></pre></div><br />
<div class="highlight"><pre><span></span><code>주소 ↓ 높은 주소
──────────────────────────────────────────────
|                                            |
|                사용자 공간 (user)         | ← 프로세스 메모리
|                                            |
|--------------------------------------------| ← 사용자가 사용하는 마지막 주소 (~0xFFFFFFFF?)
|                커널 heap                  | ← `end[]` 이후 동적 할당
|                                            |
|--------------------------------------------| ← end (PROVIDE(end = .))
|                .bss 섹션                  | ← 초기화되지 않은 전역 변수
|                                            |
|--------------------------------------------|
|                .data 섹션                 | ← 초기화된 전역 변수
|                                            |
|--------------------------------------------|
|                .rodata 섹션               | ← const 문자열 등
|                                            |
|--------------------------------------------|
|                .text 섹션                 | ← C/ASM 코드, 함수들
|                                            |
|        ┌──────────────┐                    
|        │ trampoline   │ ← trap 진입용 코드 (한 페이지)
|        └──────────────┘                    
|                                            |
|--------------------------------------------| ← 0x80000000
|              entry point (_entry)         | ← QEMU가 jump 하는 시작 주소
──────────────────────────────────────────────
주소 ↑ 낮은 주소
</code></pre></div><br />
각 섹션들은 링커가 .o들을 모아 하나의 elf를 생성하며 그때 크기가 결정된다.<br />
커널 heap은 런타임 공간이라 섹션이 아님. 저주소부터 증가하며 요청 시 크기만큼 동적으로 메모리를 할당한다.<br />
c언어 함수들을 위해 사용하는 stack0은 초기화되지 않았으므로 .bss 섹션에 포함</p>
<h3 id="2-m-kernelentrys">2&gt; M모드 및 스택 설정 kernel/entry.S</h3>
<p>cpu가 제일 먼저 읽는 파일은? _entry 라벨.</p>
<p><div class="highlight"><pre><span></span><code>        # qemu는 커널을 0x80000000에 로드
        # 각 하트(CPU)가 해당 위치로 점프하도록 함.
        # kernel.ld로 인해 다음 코드가 0x8000000위치에 배치됨.
.section .text
.global _entry
_entry:
        # C 함수에서 사용할 스택 설정.
        # stack0은 start.c에서 정의.
        # 각 CPU마다 4096Byte 스택.
        # sp = 스택포인터 = stack0 + (hartid * 4096)
        la sp, stack0                   # sp = stack0
        li a0, 1024*4                   # a0 = 4096
        csrr a1, mhartid                # 현재 하트 ID 읽어오기(0,1,2)
        addi a1, a1, 1                  # +1 (왜냐하면 stack0[0]은 쓰지 않음)
        mul a0, a0, a1                  # hartid * 4096
        add sp, sp, a0                  # sp = stack0 + (hartid * 4096)
        # start.c에 있는 start()로 점프
        call start
spin:
        j spin                          # start()는 절대 리턴하면 안되므로 혹시 리턴했을때 cpu가 멈추지 않도록 무한 루프를 둔것.
</code></pre></div><br />
<div class="highlight"><pre><span></span><code>stack0:  ┌────────────────────┐ ← 스택 바닥
         │                    │
         │      스택           │
         │                    │
         └────────────────────┘ ← sp 설정 (최상단 = stack0 + STACK_SIZE)
</code></pre></div></p>
<h3 id="3-m-s-timer-kernelstartc">3&gt; M-&gt;S 전환, timer 세팅 kernel/start.c</h3>
<p><div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;types.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;param.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memlayout.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;riscv.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;defs.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">timerinit</span><span class="p">();</span>

<span class="c1">// entry.S는 각 CPU마다 하나의 스택 필요.</span>
<span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">aligned</span><span class="w"> </span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">stack0</span><span class="p">[</span><span class="mi">4096</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NCPU</span><span class="p">];</span>

<span class="c1">// entry.S는 여기 stack0의 M 모드로 점프함.</span>
<span class="kt">void</span>
<span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// RISC-V에서는 U(유저) S(커널) M(최상위)가 있다는거 기억할거임.</span>
<span class="w">  </span><span class="c1">// 지금이 그 machine mode.</span>


<span class="w">  </span><span class="c1">// mret(machine mode return) 후 S 모드로 점프할 수 있게 준비.</span>
<span class="w">  </span><span class="c1">// MPP(machine previous privilege mode)비트 = 그 이전 모드가 어디냐 저장. 00은 U, 01은 S, 11은 M</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_mstatus</span><span class="p">();</span><span class="w">        </span><span class="c1">// 현재의 mstatus 레지스터 값을 읽어서 x에 저장. r은 read</span>
<span class="w">                                        </span><span class="c1">// x = 0x 0000 000a bc12 3800 (예시)</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">MSTATUS_MPP_MASK</span><span class="p">;</span><span class="w">               </span><span class="c1">// MSTATUS_MPP_MASK = MPP 부분인 11,12비트 마스크</span>
<span class="w">                                        </span><span class="c1">// 11을 11비트에 설정, 따라서 0x 0000 0000 0000 1800</span>
<span class="w">                                        </span><span class="c1">// ~MSTATUS_MPP_MASK는 0x FFFF FFFF FFFF E7FF</span>
<span class="w">                                        </span><span class="c1">// 즉 이건 MPP 비트(11,12)를 0으로 초기화해라</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MSTATUS_MPP_S</span><span class="p">;</span><span class="w">                   </span><span class="c1">// MSTATUS_MPP_S = S모드를 의미하는 값.</span>
<span class="w">                                        </span><span class="c1">// 01을 11비트에 설정, 따라서 0x 0000 0000 0000 0800</span>
<span class="w">                                        </span><span class="c1">// 즉 이건 MPP 비트를 01(S모드)로 설정해라</span>
<span class="w">  </span><span class="n">w_mstatus</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">                         </span><span class="c1">// 조작한 값을 다시 mstatus에 기록. w는 write</span>

<span class="w">  </span><span class="c1">// MEPC 레지스터 = mret시 복귀할 pc를 담음(주로 main. S 모드의 커널 진임점)</span>
<span class="w">  </span><span class="n">w_mepc</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">main</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// 지금은 MMU(가상 메모리) 끄고 물리 주소 모드로 작동</span>
<span class="w">  </span><span class="n">w_satp</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// 16개의 예외 레지스터, 16개의 인터럽트 레지스터를 모두 S 모드로 넘기기 위한 함수.</span>
<span class="w">  </span><span class="c1">// 1111 1111 1111 1111 16개의 비트에 대해 전부.</span>
<span class="w">  </span><span class="n">w_medeleg</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">);</span>
<span class="w">  </span><span class="n">w_mideleg</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// S 모드에서 허용할 인터럽트 종류 설정.</span>
<span class="w">  </span><span class="c1">// supervisor interrupt enable 레지스터 현재 값을 읽고 or 연산으로 3개 인터럽트 추가.</span>
<span class="w">  </span><span class="c1">// SEIE: 외부 인터럽트, STIE: 타이머 인터럽트, SSIE: 소프트웨어 인터럽트</span>
<span class="w">  </span><span class="n">w_sie</span><span class="p">(</span><span class="n">r_sie</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SIE_SEIE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SIE_STIE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SIE_SSIE</span><span class="p">);</span><span class="w">      </span><span class="c1">// 현재 설정값을 읽고 각 비트를 1로 만들어 저장</span>

<span class="w">  </span><span class="c1">// S 모드가 메모리 접근 가능하도록 PMP(physical memory protection) 설정</span>
<span class="w">  </span><span class="n">w_pmpaddr0</span><span class="p">(</span><span class="mh">0x3fffffffffffffull</span><span class="p">);</span><span class="w">      </span><span class="c1">// 최대 메모리 주소 0x 3f ffff ffff ffff * 하나당 4바이트</span>
<span class="w">  </span><span class="n">w_pmpcfg0</span><span class="p">(</span><span class="mh">0xf</span><span class="p">);</span><span class="w">                       </span><span class="c1">// 모든 권한(RWX)을 부여</span>

<span class="w">  </span><span class="c1">// 타이머 인터럽트 설정</span>
<span class="w">  </span><span class="n">timerinit</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// tp 레지스터에 hartid 저장. cpuid()함수가 이를 참조함.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_mhartid</span><span class="p">();</span>
<span class="w">  </span><span class="n">w_tp</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// mret 명령어로 S모드로 전환하고 main으로 점프</span>
<span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;mret&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="nf">timerinit</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// 타이머 인터럽트 활성화</span>
<span class="w">  </span><span class="c1">// machine interrupt enable register</span>
<span class="w">  </span><span class="c1">// STIE(spuervisor timer interrupt enable): 타이머 인터럽트</span>
<span class="w">  </span><span class="n">w_mie</span><span class="p">(</span><span class="n">r_mie</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MIE_STIE</span><span class="p">);</span><span class="w">            </span><span class="c1">// 현재 설정값을 읽고 5번 비트를 1로 만들어 저장</span>

<span class="w">  </span><span class="c1">// sstc 확장 활성화</span>
<span class="w">  </span><span class="c1">// 기존에는 M 모드에서만 mtimecmp를 설정할 수 있었지만 sstc가 활성화되면 S모드도 stimecpm 사용가능</span>
<span class="w">  </span><span class="n">w_menvcfg</span><span class="p">(</span><span class="n">r_menvcfg</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mf">1L</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">63</span><span class="p">));</span><span class="w">  </span><span class="c1">// 1L &lt;&lt; 63이 sstc를 활성화함</span>

<span class="w">  </span><span class="c1">// mcounteren 레지스터는 어떤 카운터를 s모드에서 읽을 수 있게 허용할지 결정</span>
<span class="w">  </span><span class="c1">// 0번째 비트는 사이클 수 관련, 1비트는 시간 카운터, 2비트는 명령어 실행 수를 의미.</span>
<span class="w">  </span><span class="n">w_mcounteren</span><span class="p">(</span><span class="n">r_mcounteren</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">     </span><span class="c1">// 1번째 비트를 킴 -&gt; 시간 카운터 허용</span>

<span class="w">  </span><span class="c1">// S모드 timecompare 타이머 비교 레지스터</span>
<span class="w">  </span><span class="c1">// stimecmp보다 커지면 타이머 인터럽트 발생</span>
<span class="w">  </span><span class="n">w_stimecmp</span><span class="p">(</span><span class="n">r_time</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1000000</span><span class="p">);</span><span class="w">       </span><span class="c1">// 현재 시간+100만 tick(1초)으로 stimecmp 설정</span>
<span class="p">}</span>
</code></pre></div><br />
참고로 타이머는 유일하게 cpu 안에 있는 순수 하드웨어 타이머로, M모드 소속 자원이자 모든 스케줄링의 기반이기에 여기에 정의되어 있다.</p>
<h3 id="4-kernelmainc">4&gt; 커널 초기화 루틴 kernel/main.c</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;types.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;param.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memlayout.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;riscv.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;defs.h&quot;</span>

<span class="k">volatile</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">started</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">        </span><span class="c1">// 부트 hart가 초기화 끝났는지 표시하는 플래그</span>
<span class="w">                                        </span><span class="c1">// volatile: 컴파일러가 최적화로 생략하지 말고 꼭 메모리에서 읽게 함</span>

<span class="kt">void</span>
<span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">cpuid</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w">                     </span><span class="c1">// cpu0 = 부트 hart만이 전체 시스템 초기화를 맡음</span>
<span class="w">    </span><span class="n">consoleinit</span><span class="p">();</span><span class="w">                      </span><span class="c1">// UART, printf, getc 등 콘솔 입출력 초기화</span>
<span class="w">    </span><span class="n">printfinit</span><span class="p">();</span><span class="w">                       </span><span class="c1">// printf 내부 버퍼 초기화</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;xv6 kernel is booting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">kinit</span><span class="p">();</span><span class="w">                            </span><span class="c1">// 물리 메모리 페이지 할당기 초기화</span>
<span class="w">    </span><span class="n">kvminit</span><span class="p">();</span><span class="w">                          </span><span class="c1">// 커널 전용 페이지 테이블 생성</span>
<span class="w">    </span><span class="n">kvminithart</span><span class="p">();</span><span class="w">                      </span><span class="c1">// 현재 하트에 페이지 테이블 적용. MMU 활성화</span>
<span class="w">    </span><span class="n">procinit</span><span class="p">();</span><span class="w">                         </span><span class="c1">// 프로세스 테이블 초기화</span>
<span class="w">    </span><span class="n">trapinit</span><span class="p">();</span><span class="w">                         </span><span class="c1">// trap 관련 전역 설정. 트랩 핸들러 vector table 준비</span>
<span class="w">    </span><span class="n">trapinithart</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 해당 hart에 트랩 핸들러 벡터 주소 등록</span>
<span class="w">    </span><span class="n">plicinit</span><span class="p">();</span><span class="w">                         </span><span class="c1">// 플랫폼 레벨 interrupt controller 초기화</span>
<span class="w">    </span><span class="n">plicinithart</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 현재 하트에 연결된 인터럽트를 활성화</span>
<span class="w">    </span><span class="n">binit</span><span class="p">();</span><span class="w">                            </span><span class="c1">// 블록 버퍼 캐시 초기화</span>
<span class="w">    </span><span class="n">iinit</span><span class="p">();</span><span class="w">                            </span><span class="c1">// inode 테이블 초기화</span>
<span class="w">    </span><span class="n">fileinit</span><span class="p">();</span><span class="w">                         </span><span class="c1">// 전역 파일 디스크립터 테이블 초기화</span>
<span class="w">    </span><span class="n">virtio_disk_init</span><span class="p">();</span><span class="w">                 </span><span class="c1">// qemu 가상 디스크 장치 초기화</span>
<span class="w">    </span><span class="n">userinit</span><span class="p">();</span><span class="w">                         </span><span class="c1">// 최초 유저 프로세스를 생성</span>
<span class="w">    </span><span class="n">__sync_synchronize</span><span class="p">();</span><span class="w">               </span><span class="c1">// 메모리 순서를 강제 정렬</span>
<span class="w">    </span><span class="n">started</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">                        </span><span class="c1">// 플래그 1로</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">                              </span><span class="c1">// 나머지 하트는</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">started</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">                 </span><span class="c1">// 부트 하트가 started = 1 해주기까지 대기하는 루프</span>
<span class="w">      </span><span class="p">;</span>
<span class="w">    </span><span class="n">__sync_synchronize</span><span class="p">();</span><span class="w">               </span><span class="c1">// 메모리 순서를 강제 정렬</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;hart %d starting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cpuid</span><span class="p">());</span>
<span class="w">    </span><span class="n">kvminithart</span><span class="p">();</span><span class="w">                      </span><span class="c1">// 현재 하트에 페이지 테이블 적용. MMU 활성화</span>
<span class="w">    </span><span class="n">trapinithart</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 해당 hart에 트랩 핸들러 벡터 주소 등록</span>
<span class="w">    </span><span class="n">plicinithart</span><span class="p">();</span><span class="w">                     </span><span class="c1">// 현재 하트에 연결된 인터럽트를 활성화</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">scheduler</span><span class="p">();</span><span class="w">                          </span><span class="c1">// 모든 cpu가 스케줄러에 진입하여 프로세스 루프  </span>
<span class="p">}</span>
</code></pre></div>
<h3 id="5">5&gt; 모드 전환</h3>
<p>mret : M-&gt;S<br />
mstatus.MPP를 보고 다음 모드를 결정<br />
MPP=00(U모드) MPP=01(S모드) MPP=11(M모드)<br />
mepc에 저장된 주소(main)로 점프</p>
<p>sret : S-&gt;U<br />
sstatus.SPP을 보고 다음 모드를 결정<br />
SPP=0(U모드) SPP=1(S모드)<br />
sepc에 저장된 주소(유저 앱)로 점프<br />
유저 앱 실행 시 SPP=0, sepc=유저코드, sret();</p>
<p>trap : U-&gt;S<br />
직접적으로 상위 모드로 못올라가지만 예외 발생시.(ecall)<br />
stvec에 등록된 trap handler로 점프. SPP=U모드. sepc에 복귀 주소 저장됨</p>
<p>trap이 언제 발생하나요?<br />
예외 : ecall, 잘못된 주소 접근<br />
인터럽트 : 타이머, 장치I/O</p>
<div class="highlight"><pre><span></span><code>[U 모드] 유저 코드 실행 중
    ↓
  trap 발생 (ex. ecall, timer)
    ↓
[하드웨어]
  sepc ← 복귀 주소 저장
  sstatus ← 현재 모드 저장
  PC ← stvec 에 등록된 handler로 점프
    ↓
[S 모드] 커널의 trap handler 동작
</code></pre></div>
<h3 id="makefile">&gt; makefile</h3>
<p>[ test.S ] --(어셈블러)--&gt; [ test.o ] --(링커)--&gt; [ kernel.elf ] --(objcopy)--&gt; [ kernel.img ]<br />
어셈블리 → 오브젝트 : CPU가 이해할 수 있는 기계어(.o)로 변환<br />
오브젝트 → ELF 실행파일 : 코드와 데이터(섹션)들을 주소에 맞게 배치<br />
ELF → 바이너리 이미지 : ELF 헤더 제거, 부트로더/에뮬레이터가 바로 읽을 수 있게</p>
<p>툴체인이란 컴파일 전 과정을 담당하는 도구 세트이다.<br />
(gcc / as / ld / objdump / gdb …)<br />
gcc : .c -&gt; 중간 IR -&gt; 어셈블리 -&gt; .o<br />
이때 -c 옵션을 주면 여기까지만 하고 링크는 하지 않음<br />
as : .S -&gt; .o<br />
ld : 여러 개의 .o와 라이브러리를 하나의 실행가능 elf로 묶음. 링커 스크립트에 따라 주소, 섹션 배치 결정<br />
objcopy : 불필요한 섹션 제거 및 elf를 순수 바이너리로 바꾸기<br />
objdump : 합쳐진 elf파일을 우리가 볼 수 있도록 다시 어셈블리어로 뽑아준 참고용 해설서.<br />
-S 옵션은 어셈블리, -t 옵션은 심볼 테이블 등.<br />
gdb : 실행 파일 조사 디버깅</p>
<p>크로스 컴파일이란 x86-64 노트북에서 RISC-V용 커널을 빌드하는 것을 말한다.<br />
동일 아키텍트면 네이티브 컴파일.</p>
<p>따라서 크로스 컴파일용 툴체인은 이름으로 CPU와 OS 대상을 표시한다. (네이티브 컴파일 툴체인 이름과 구분)<br />
<CPU>-<VENDOR>-<OS/ABI><br />
vendor? 툴체인 제작사. 없으면 unknown<br />
OS/ABI? C 라이브러리 규약. 즉 어떤 상황에서 런 시킬건지 미리 대비해 그에 맞춰 커널 이미지를 준비함.(elf 환경인지, glibc가 존재하는 환경인지)</p>
<p>riscv64-unknown-elf는 RISC-V용 베어메탈 elf 실행포맷 환경 크로스 컴파일 툴체인. 즉 펌웨어, 커널, 임베디드 대상. OS 없음 → 직접 MMIO·폴링·trap 구현<br />
riscv64-linux-gnu는 리눅스에서 만든 RISC-V용 GNU libc 환경 크로스 컴파일 툴체인. 즉 유저 공간 프로그램 대상.</p>
<p>이때 xv6은 os가 리눅스가 아니기에 gnu libc나 시스템 콜이 필요하지 않고, qemu가 커널 elf를 0x80000000에 바로 로드하기에 부트로더 또한 필요하지 않고, 커널 안에서 자체 printf와 memcpy를 구현하기에 libc 또한 필요하지 않다.<br />
riscv64-unknown-elf로 충분하다. 그 도구만 있어도 컴파일(.o 생성), 링크(커널.ld로 elf 만들기), 실행(qemu가 elf를 메모리에 배치)가 모두 가능하다.</p>
<p>컴파일 단계 – Host PC에 RISC-V 크로스-툴체인이 있어야 Makefile이 통과.<br />
실행 단계 – 생성된 kernel·fs.img 등을 QEMU가 부팅.<br />
만약 컴파일한 kernel elf를 qemu가 아닌 실제 하드웨어 기기에서 부팅시키고 싶다면 openSBI 등을 활용해라. 걔가 커널 elf를 0x80000000으로 데려가는 부트로더 역할을 한다.</p>
<p><div class="highlight"><pre><span></span><code># 여기부터 별칭 명명과 소스파일과 툴 준비

# 별칭
# GNU make에서 =는 재귀확장 변수(매번 변수를 참초), :=는 단순확장 변수(대입순간 단 한번 그뒤로 상수)
K=kernel
U=user

# 커널 오브젝트 파일 목록
# .c -&gt; .o는 명령어로 적어주지 않아도 내장 규칙으로 수행
OBJS = \
  $K/entry.o \
  $K/start.o \
  $K/console.o \
  $K/printf.o \
  $K/uart.o \
  $K/kalloc.o \
  $K/spinlock.o \
  $K/string.o \
  $K/main.o \
  $K/vm.o \
  $K/proc.o \
  $K/swtch.o \
  $K/trampoline.o \
  $K/trap.o \
  $K/syscall.o \
  $K/sysproc.o \
  $K/bio.o \
  $K/fs.o \
  $K/log.o \
  $K/sleeplock.o \
  $K/file.o \
  $K/pipe.o \
  $K/exec.o \
  $K/sysfile.o \
  $K/kernelvec.o \
  $K/plic.o \
  $K/virtio_disk.o

# riscv64-unknown-elf-나 riscv64-linux-gnu-는 /opt/riscv/bin에 있을 거임
# TOOLPREFIX = 로 따로 설정도 가능
# make toolprefix로 따로 명명하지 않았을때 자동 탐색
# objdump = 설명서. 여기선 헤더 확인한거임
# -i는 지원 포맷 목록을 출력
# 2&gt;&amp;1 = 리다이렉션 명령어. stderr를 stdout으로 합쳐라
# &gt;/dev/null = 출력은 폐기하고 성공 실패 여부만 남김
# 탐색에 성공하면 출력하여 shell의 반환값이 됨
# 세 후보가 모두 실패했으면 exit 1로 make 자체를 중단
# 1&gt;&amp;2 = stdout을 stderr로 합쳐서 빨간 글씨로 눈에 잘띄게.
ifndef TOOLPREFIX
TOOLPREFIX := $(shell \
  if riscv64-unknown-elf-objdump -i 2&gt;&amp;1 | grep &#39;elf64-big&#39; &gt;/dev/null 2&gt;&amp;1; \
    then echo &#39;riscv64-unknown-elf-&#39;; \
    elif riscv64-linux-gnu-objdump -i 2&gt;&amp;1 | grep &#39;elf64-big&#39; &gt;/dev/null 2&gt;&amp;1; \
    then echo &#39;riscv64-linux-gnu-&#39;; \
    elif riscv64-unknown-linux-gnu-objdump -i 2&gt;&amp;1 | grep &#39;elf64-big&#39; &gt;/dev/null 2&gt;&amp;1; \
    then echo &#39;riscv64-unknown-linux-gnu-&#39;; \
    else echo &quot;***&quot; 1&gt;&amp;2; \
    echo &quot;*** Error: Couldn&#39;t find a riscv64 version of GCC/binutils.&quot; 1&gt;&amp;2; \
    echo &quot;*** To turn off this error, run &#39;gmake TOOLPREFIX= ...&#39;.&quot; 1&gt;&amp;2; \
    echo &quot;***&quot; 1&gt;&amp;2; exit 1; fi)
endif

QEMU = qemu-system-riscv64

# as vs gas ― 이름만 다르고 실체는 같다
CC = $(TOOLPREFIX)gcc
AS = $(TOOLPREFIX)gas
LD = $(TOOLPREFIX)ld
OBJCOPY = $(TOOLPREFIX)objcopy
OBJDUMP = $(TOOLPREFIX)objdump



# 여기부터 c compiler flags와 linker flags 설정

# -Wall 모든 경고 켜기 -Werror 경고를 오류로 취급 -O 기본 최적화(O1)
# -fno~ 프레임 포인터 유지 -ggdb~ dwarf-2 디버그 심볼 삽입
# -MD .c 타킷과 헤더 연결로 이루어진 의존성 .d 파일. 헤더를 수정하면 해당 .o만 재컴파일하도록 하기 위함.
# -mcmodel medlow 모델이면 텍스트 섹션도 데이터 섹션도 2GB(31bit) 이내에 있어야함(작은 펌웨어). medany 모델이면 텍스트는 현재 pc에서 2GB, 데이터는 어디든 32bit이어야 함. large 모델이면 64bit 절대주소를 즉시값으로 넣음
# 예를 들어 0x80004000(텍스트 섹션) pc 지점에서 전역변수 0x80011234(데이터 섹션)를 찾으려 하면 이는 0x0000D234 즉 52KB 차이이다. auipc t0, hi20(+0x0d000)과 addi t0, t0, lo12(0x234)로 도달가능.
# 주석 부분은 완전 bare-metal 옵션 세트. -ffreestanding 표준 C 라이브러리 존재를 가정하지 말라 -mno-relax 릴랙스 최적화를 끔
# 그 중 두개만 열어놓음 -fno-common 중복 전역 심볼을 오류 처리 -nostdlib 커널이니 crt0/libc 링크 안함
# -fno-buildtin-17종 컴파일러 자체 최적화 대상에서 제외(커널이 구현한 함수와 충돌x)
# -Wno-main main 반환값 없다고 경고x
# -I 현재 디렉토리를 include 탐색 경로에 추가(include 파일이 어디에 있든 찾기 가능)
# 마지막 줄은 cc가 스택 보호기를 인식(-E로 컴파일 없이 전처리 했을 때 종료코드 0)하면 추가하라. 실패하면 조용히 넘어가라.
# 즉 커널은 자급자족 코드라 libc/시작파일이 필요 없고, 컴파일러 내장 builtin/스택보호/PIE를 꺼둔다
CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
CFLAGS += -MD
CFLAGS += -mcmodel=medany
# CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
CFLAGS += -fno-common -nostdlib
CFLAGS += -fno-builtin-strncpy -fno-builtin-strncmp -fno-builtin-strlen -fno-builtin-memset
CFLAGS += -fno-builtin-memmove -fno-builtin-memcmp -fno-builtin-log -fno-builtin-bzero
CFLAGS += -fno-builtin-strchr -fno-builtin-exit -fno-builtin-malloc -fno-builtin-putc
CFLAGS += -fno-builtin-free
CFLAGS += -fno-builtin-memcpy -Wno-main
CFLAGS += -fno-builtin-printf -fno-builtin-fprintf -fno-builtin-vprintf
CFLAGS += -I.
CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)

# PIE(포지션 독립 실행가능) 끄기 -우분투 16.10 툴체인에서 기본으로 켜질 수 있음
# ifnoteq 같지 않으면 실행하라는 뜻. , 다음이 빈칸이니까 앞의 결과가 출력물이 존재하면 실행하라는게 됨.
# cc의 스펙 파일 전체를 출력하여 그 중 &#39;f&#39;가 아닌 no-pie를 찾아라
# 그래서 존재하면 -no-pie 옵션을 켜 PIE 끄기
ifneq ($(shell $(CC) -dumpspecs 2&gt;/dev/null | grep -e &#39;[^f]no-pie&#39;),)
CFLAGS += -fno-pie -no-pie
endif
ifneq ($(shell $(CC) -dumpspecs 2&gt;/dev/null | grep -e &#39;[^f]nopie&#39;),)
CFLAGS += -fno-pie -nopie
endif

# ELF 섹션 정렬 시 페이지 크기 4KB로 고정
LDFLAGS = -z max-page-size=4096



# 여기부터 타깃 설정

# kernel = .o들 + 링커파일  + initcode
# 설정플래그 + 링커파일과 + .o들 -&gt; 커널.elf 만들기
# 디스어셈블로 설명서 만들기
# 불필요 헤더 삭제하고 심볼 테이블 추출
$K/kernel: $(OBJS) $K/kernel.ld $U/initcode
    $(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
    $(OBJDUMP) -S $K/kernel &gt; $K/kernel.asm
    $(OBJDUMP) -t $K/kernel | sed &#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#39; &gt; $K/kernel.sym

# initcode란 xv6가 부팅직후 userinit()에서 메모리에 복사 실행하는 최초 사용자 공간 코드
# 커널은 앞에서 만든거고 이건 프로세스다. 유일하게 이것만 커널에도 넣어줌
# 설정플래그 + .S -&gt; .o 만들기
# -march-rv64g 모든 표준 확장 사용 -nostdinc 시스템 헤더 무시
# .o -&gt; .out 만들기
# -N .text(RX)/.data(RW)를 모두 하나의 RWX 덩어리로 만들어서 재배치 없음
# -e start 엔트리포인트 심볼을 start로 설정
# -Ttext 0 가상주소 0부터 배치하여 xv6커널이 유저 공간에 로드하기 편함
# 순수 바이너리 파일 만들고 설명서 만들기
$U/initcode: $U/initcode.S
    $(CC) $(CFLAGS) -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o
    $(LD) $(LDFLAGS) -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o
    $(OBJCOPY) -S -O binary $U/initcode.out $U/initcode
    $(OBJDUMP) -S $U/initcode.o &gt; $U/initcode.asm

# 모든 c와 S에 대해 심볼 색인 파일 생성. 전부 탐색하도록 빌드 산출물 의존을 걸어둠.
tags: $(OBJS) _init
    etags *.S *.c



# 여기부터 유저 프로세스 설정

# 유저 프로그램용 정적 라이브러리 묶음
ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o

# 라이브러리 참조해 유저 프로그램 _cat같은 실행파일 만들기
# _%는 패턴 규칙에 의해 알아서 _cat을 만들어야겠네? 하고 타깃 발동
# $@은 정해진 타깃이름 참조 $^는 모든 의존 목록
_%: %.o $(ULIB)
    $(LD) $(LDFLAGS) -T $U/user.ld -o $@ $^
    $(OBJDUMP) -S $@ &gt; $*.asm
    $(OBJDUMP) -t $@ | sed &#39;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#39; &gt; $*.sym

# perl 스크립트 usys.pl을 .o로 만들기
$U/usys.S : $U/usys.pl
    perl $U/usys.pl &gt; $U/usys.S

$U/usys.o : $U/usys.S
    $(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S

# 프로세스 테이블을 채우는 테스트 실행파일 만들기
# -N .text/.data를 한 덩어리 RWX에
# -e main 엔트리 심볼을 main으로
# -Ttext 0 가상주소 0으로 링크
$U/_forktest: $U/forktest.o $(ULIB)
    $(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_forktest $U/forktest.o $U/ulib.o $U/usys.o
    $(OBJDUMP) -S $U/_forktest &gt; $U/forktest.asm

# 호스트(내pc)용 실행파일 mkfs 만들기
# 커널과 mkfs간 구조체와 상수가 같도록 커널에서 fs.h 파일시스템 정의 param.h 상수 정의 가져옴
# 네이티브 gcc
mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
    gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c

# GNU make에서는 중간 파일 .o를 디폴트로 삭제하지만, 공유하거나 fs.img 재생성을 막기 위해 남겨둠
.PRECIOUS: %.o

# 사용할 유저 프로그램 목록
UPROGS=\
    $U/_cat\
    $U/_echo\
    $U/_forktest\
    $U/_grep\
    $U/_init\
    $U/_kill\
    $U/_ln\
    $U/_ls\
    $U/_mkdir\
    $U/_rm\
    $U/_sh\
    $U/_stressfs\
    $U/_usertests\
    $U/_grind\
    $U/_wc\
    $U/_zombie\

# 유저 프로그램 이미지 파일 생성(호스트에서)
fs.img: mkfs/mkfs README $(UPROGS)
    mkfs/mkfs fs.img README $(UPROGS)

# 파일이 아직 없더라도(첫빌드) 넘어가는 장치
-include kernel/*.d user/*.d



# 여기부터 추가 기능

clean: 
    rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
    */*.o */*.d */*.asm */*.sym \
    $U/initcode $U/initcode.out $K/kernel fs.img \
    mkfs/mkfs .gdbinit \
        $U/usys.S \
    $(UPROGS)

# 호스트 UID로부터 고유한 GDB TCP 포트 계산. 몰리지 않게.
GDBPORT = $(shell expr `id -u` % 5000 + 25000)
# qemu 도움말에 -gdb 옵션이 있으면 -gdb tcp port 형식 사용, 없으면 구버전 -s -p port 사용
QEMUGDB = $(shell if $(QEMU) -help | grep -q &#39;^-gdb&#39;; \
    then echo &quot;-gdb tcp::$(GDBPORT)&quot;; \
    else echo &quot;-s -p $(GDBPORT)&quot;; fi)
# 하트수
ifndef CPUS
CPUS := 3
endif

# -bios none: OpenSBI같은 펌웨어 건너뜀 -kernel: 커널 elf 직접 로드
# -m 128M: RAM 128MB -smp $(CPUS): 하트수 -nographic: 콘솔만
# virtio-mmio 추가. fs.img 넣기.
QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
QEMUOPTS += -global virtio-mmio.force-legacy=false
QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0

qemu: $K/kernel fs.img
    $(QEMU) $(QEMUOPTS)

# GDBPORT를 로컬에선 1234로 치환. 그리고 자동실행.
.gdbinit: .gdbinit.tmpl-riscv
    sed &quot;s/:1234/:$(GDBPORT)/&quot; &lt; $^ &gt; $@

# -S: qemu를 리셋 직후 정지. 다른 창에서 gdb 실행하면 됨
qemu-gdb: $K/kernel .gdbinit fs.img
    @echo &quot;*** Now run &#39;gdb&#39; in another window.&quot; 1&gt;&amp;2
    $(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
</code></pre></div><br />
<div class="highlight"><pre><span></span><code>               ┌─ kernel (S-mode) ───────────────────────────┐
               │ main() → userinit()                         │
               │            │                                │
1. 부팅 완료 ──┘            ▼                                │
2. initproc 생성          (커널 내장)                         │
      → `p-&gt;pagetable`   +--------------------------------+  │
      → `memmove()`      |   RAW   initcode   binary      |  │
      → `p-&gt;trapframe`   +--------------------------------+  │
      → `epc = 0`        ^  (VA 0x0)                       │
               │         │  4 KiB  |R/W/X|                 │
               └─────────┴────────┴────────────────────────┘
                         ↓ sret (U-mode 진입)
</code></pre></div><br />
<strong>initcode</strong> 실행 (U-mode)<br />
<em>간단한 hand-written 어셈블리</em><br />
<div class="highlight"><pre><span></span><code><span class="nf">li</span><span class="w">  </span><span class="no">a0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w">        </span><span class="c1"># argv=0</span>
<span class="nf">auipc</span><span class="w"> </span><span class="no">a1</span><span class="p">,</span><span class="w"> </span><span class="no">init</span><span class="w">   </span><span class="c1"># &quot;init&quot; 문자열</span>
<span class="nf">ecall</span><span class="w"> </span><span class="no">SYS_exec</span><span class="w">   </span><span class="c1"># exec(&quot;/init&quot;)</span>
<span class="nf">ecall</span><span class="w"> </span><span class="no">SYS_exit</span><span class="w">   </span><span class="c1"># 만약 실패하면 종료</span>
</code></pre></div></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "content.code.copy", "header.autohide"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.56ea9cef.min.js"></script>
      
    
  </body>
</html>